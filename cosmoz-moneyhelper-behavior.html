<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../accounting/accounting.min.js"></script>

<script type="text/javascript">
	(function () {
		'use strict';
		/* global accounting */
		window.Cosmoz = window.Cosmoz || {};

		const formats = {
			CNY: {
				currency: {
					symbol: '¥',     // Default currency symbol is '$'.
					format: '%s %v', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: ',',    // Decimal point separator.
					thousand: ' ',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0.
					thousand: ',',
					decimal: '.'
				}
			},
			DKK: {
				currency: {
					symbol: 'kr',    // Default currency symbol is '$'.
					format: '%v %s', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: ',',    // Decimal point separator.
					thousand: ' ',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0.
					thousand: ',',
					decimal: '.'
				}
			},
			EUR: {
				currency: {
					symbol: '€',     // Default currency symbol is '$'.
					format: '%s %v', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: ',',    // Decimal point separator.
					thousand: '.',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0.
					thousand: ',',
					decimal: '.'
				}
			},
			NOK: {
				currency: {
					symbol: 'kr',    // Default currency symbol is '$'.
					format: '%v %s', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: ',',    // Decimal point separator.
					thousand: ' ',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0.
					thousand: ',',
					decimal: '.'
				}
			},
			SEK: {
				currency: {
					symbol: 'kr',    // Default currency symbol is '$'.
					format: '%v %s', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: ',',    // Decimal point separator.
					thousand: ' ',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0
					thousand: ',',
					decimal: '.'
				}
			},
			USD: {
				currency: {
					symbol: '$',     // Default currency symbol is '$'.
					format: '%s %v', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: '.',    // Decimal point separator.
					thousand: ',',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0.
					thousand: ',',
					decimal: '.'
				}
			},
			ZAR: {
				currency: {
					symbol: 'ZAR',   // Default currency symbol is '$'.
					format: '%s %v', // Controls output: %s = symbol, %v = value/number (can be object: see below).
					decimal: ',',    // Decimal point separator.
					thousand: ' ',   // Thousands separator.
					precision: 2     // Decimal places.
				},
				number: {
					precision: 0, // Default precision on numbers is 0.
					thousand: ' ',
					decimal: ','
				}
			}
		};
		/**
		 * Behavior for amount and money management.
		 *
		 * @polymerBehavior Cosmoz.MoneyHelperBehavior
		 * @demo
		 */
		Cosmoz.MoneyHelperBehavior = {
			/**
			 * Compare amounts.
			 * @param {object} amount1 Amount 1.
			 * @param {object} amount2 Amount 2.
			 * @param {number} precision Decimal precision, defaults to 2 decimals.
			 * @returns {boolean} Whether the amounts are equal regarding amount to the specified precision and the currency.
			 */
			amountEquals(amount1, amount2, precision = 2) {
				return this.isAmount(amount1) && this.isAmount(amount2) &&
					this.round(amount1.amount, precision) === this.round(amount2.amount, precision) &&
					amount1.currency === amount2.currency;
			},
			/**
			 * Determine if a constant or a variable is an amount.
			 * @param {object} potentialAmount Potential amount.
			 * @returns {boolean} Whether the potential amount is a valid amount object with amount and currency.
			 */
			isAmount: potentialAmount =>
				potentialAmount != null &&
				potentialAmount.amount != null &&
				potentialAmount.currency != null &&
				typeof potentialAmount.amount === 'number' &&
				typeof potentialAmount.currency === 'string' &&
				potentialAmount.currency.length === 3,
			/**
			 * Render an amount with decimal separator and currency symbol.
			 * @param  {object} money Money with amount property and optionally currency property.
			 * @return {string} Formatted amount.
			 */
			renderAmount(money) {
				if (money == null) {
					return;
				}
				const format = this._renderFormat(money);
				return accounting.formatMoney(money.amount, format.currency);
			},
			/**
			 * Alias for renderAmount(money). Render an amount with decimal separator and currency symbol.
			 * @param  {object} money Money with amount property and optionally currency property.
			 * @return {string} Formatted amount.
			 */
			renderMoney(money) {
				return this.renderAmount(money);
			},
			/**
			 * Render an amount with decimal separator but without currency symbol.
			 * @param  {object} money Money with amount property and optionally currency property.
			 * @return {string} Formatted number.
			 */
			renderNumberAmount(money) {
				const format = this._renderFormat(money);
				return accounting.formatNumber(money.amount, format.currency);
			},
			/**
			 * Remove currency formatting including decimal separator and currency symbol.
			 * @param  {string} amountString Amount to unformat.
			 * @param  {string} decimalSeparator Decimal separator to use, all but comma are ignored.
			 * @return {number} Unformatted amount with decimals.
			 */
			unformatRenderedAmount(amountString, decimalSeparator) {
				return accounting.unformat(amountString, decimalSeparator === ',' ? ',' : '');
			},
			/**
			 * Round a number to a given precision.
			 * @param  {string} number Number with decimals to round.
			 * @param  {number} precision Number of decimals to round amount to.
			 * @return {number} Rounded number.
			 */
			round(number, precision) {
				return parseFloat(accounting.toFixed(number, precision));
			},
			_renderFormat(money) {
				if (money === undefined) {
					return;
				}
				if (money.amount === undefined || money.currency === undefined) {
					return (money.amount === undefined
						? ''
						: money.amount) + ' ' + (money.currency === undefined
						? ''
						: money.currency);
				}
				const format = formats[money.currency];
				if (!format) {
					return money.amount + ' ' + money.currency;
				}
				return format;
			}
		};
	}());
</script>